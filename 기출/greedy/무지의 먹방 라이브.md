## 사고과정
처음에는 그리디로 접근하지 못하고 무작정 food_times에 있는 음식 순서대로 k초 동안 1씩 빼주면 되지않나? 라고 생각<br>
while문으로 k가 0이 될 때까지 돌리고 그 안에서 for문으로 food_times 요소를 하나씩 검사하며 1씩 빼주었다.
아주 무식하게 품..
정확성: 4.0 효율성: 0.0 ... 도저히 모르겠어서 책에 나온 풀이 봄

## 풀이
k초에 먹을 수 있는 음식을 최대한 제거한 후에 마지막으로 먹을 음식을 찾는 식으로 접근했어야 했다<br>
다음에 풀 땐 더 고민해보고 greedy로 어떻게 접근할지 더 생각해보자<br>

아래 풀이가 이해가 가질 않는다<br>
<b>sum_value + (현재의 음식 시간 - 이전 음식 시간) * 현재 음식 개수와 k 비교</b><br>

매번 가장 시간이 짧은 음식을 먹게 되면, 그 다음으로 시간이 적은 음식을 먹을 때는 그 전에 먹은 음식의 총 시간을 빼야한다.<br>
- 왜 이전 음식 시간을 빼는가?<br>
<a href="https://github.com/ndb796/python-for-coding-test/issues/34">풀이 이해를 돕기 위한 깃헙 이슈</a><br>

---

1번 음식: 8s        
2번 음식: 6s     
3번 음식: 4s     
k = 15     
이 있다고 가정하자.    

회전판이 돌면서 음식의 순서는 생각하지 않고 시간이 짧은 음식 순으로 정렬해서 회전판을 한바퀴 돌린다고 생각하면    

 __setp 1.__   
 - 4초인 음식을 다 먹기 위해서는 회전판이 4바퀴 돌아야한다. 4바퀴 도는데 걸리는 시간은 4 * (회전판에 남은 음식)     
     => 4 * 3 = 12    
 - 4초인 음식을 다 먹기위해 12초가 소요되었으므로 k에 12를 빼줘야한다. (15 - 12 = 3) 남은 시간을 k = 3초    

 __step 2.__        
 - 6초인 음식을 다 먹기 위해서 회전판이 6바퀴 돌아야한다.
 - 4초인 음식이 빠지고 6바퀴 도는데 걸리는 시간은 6 * 2(4초인 음식이 빠지고 남은 음식의 개수) = 12 인데 여기서 step 1에서 4초인 음식을 먹기위해 회전판이 돌면서 6초인 음식도 먹었을 것이다. 그러면 step 2에서의 6초의 음식은 6초보다 짧아졌을 것이다.
 - step 1 에서 4바퀴를 돌렸으므로 6초 남은 음식은 (6 - 4 = 2) 2초가 남았을 것이고, 이 결과에 따라서 2초가 남은 음식을 모두 먹기위해 회전판을 2바퀴 돌려야한다. 따라서 총 2(남은 음식 개수) * 2(음식을 먹는데 걸리는 시간) = 4초가 걸린다.
 - k = 3초가 남았고 6초인 남은 음식을 먹기위해 4초가 걸린다. 6초의 남은 음식을 다 먹지 못하므로 남은 음식 중 k = 3 초 후에 몇번 음식을 먹어야 하는지 찾아야한다.